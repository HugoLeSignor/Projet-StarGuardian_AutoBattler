{# templates/matchmaking/search.html.twig #}
{% extends 'base.html.twig' %}

{% block title %}Recherche de partie{% endblock %}

{% block body %}
<div class="matchmaking">
    <div class="matchmaking__vignette"></div>

    <div class="matchmaking__panel">
        <div class="matchmaking__ornament">&#x2726;</div>

        <h1 class="matchmaking__title">Recherche en cours</h1>

        <div class="matchmaking__separator">
            <span></span>
            <i class="fas fa-crossed-swords"></i>
            <span></span>
        </div>

        <div class="matchmaking__spinner">
            <div class="matchmaking__ring"></div>
            <i class="fas fa-skull"></i>
        </div>

        <p class="matchmaking__status" id="matchmaking-status">
            En attente d'un adversaire...
        </p>

        <div class="matchmaking__dots" id="matchmaking-dots">
            <span></span><span></span><span></span>
        </div>

        <p class="matchmaking__hint">
            Un adversaire sera trouv&eacute; sous peu. Si aucun joueur n'est disponible, un bot prendra sa place.
        </p>

        <div class="matchmaking__separator matchmaking__separator--small">
            <span></span>
            <span></span>
        </div>

        <a href="{{ path('app_teams') }}" class="btn-dd btn-dd--secondary" id="matchmaking-cancel">
            Annuler
        </a>

        <div class="matchmaking__ornament">&#x2726;</div>
    </div>
</div>

<script>
    let queueId = null;
    let pollingInterval = null;
    const statusEl = document.getElementById('matchmaking-status');

    fetch('/matchmaking/join', {
        method: 'POST',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: ''
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.queueId) {
            queueId = data.queueId;
            startPolling();
        } else {
            statusEl.textContent = 'Erreur lors de la recherche.';
            statusEl.classList.add('matchmaking__status--error');
        }
    })
    .catch(() => {
        statusEl.textContent = 'Erreur lors de la recherche.';
        statusEl.classList.add('matchmaking__status--error');
    });

    function startPolling() {
        pollingInterval = setInterval(() => {
            fetch('/matchmaking/search', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: 'queueId=' + encodeURIComponent(queueId)
            })
            .then(response => response.json())
            .then(data => {
                if (data.found && data.redirectUrl) {
                    clearInterval(pollingInterval);
                    statusEl.textContent = 'Adversaire trouv\u00e9 !';
                    statusEl.classList.add('matchmaking__status--found');
                    document.getElementById('matchmaking-dots').style.display = 'none';
                    setTimeout(() => {
                        window.location.href = data.redirectUrl;
                    }, 800);
                }
            });
        }, 2000);
    }

    window.addEventListener('beforeunload', function() {
        if (queueId) {
            navigator.sendBeacon('/matchmaking/cancel');
        }
    });
</script>
{% endblock %}
